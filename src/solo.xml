<?xml version="1.0" encoding="UTF-8"?>

<!-- This file is part of the book                -->
<!--                                              -->
<!--       Git for Authors                        -->
<!--                                              -->
<!-- Copyright (C) 2016  Robert A. Beezer         -->
<!-- See the file COPYING for copying conditions. -->

<chapter xml:id="solo">
    <title>All By Yourself</title>

    <introduction>
        <p><c>git</c> is at its best when people collaborate, but it can still be valuable to an individual, and you may gain collaborators or contributors in the later stages of a project.  We can understand some basic concepts by considering first the simple situation of a single, solo contributor.</p>

        <p>You will not fully appreciate all of our Principles on a first reading, but if you come back to review them, they may be more useful on each reading.  Here is one such.</p>

        <principle xml:id="principle-manage-changes">
            <title>git Manages Changes</title>

            <statement>
                <p><c>git</c> manages collections of changes to your files.  And it does so in linear sequences of incremental changes that are always consistent.</p>
            </statement>
        </principle>

        <p>You may be very comfortable with organizing your writing as a collection of files, perhaps further organized in a series of directories or folders, perhaps even nested several levels deep.  <c>git</c> works on, and manipulates, your files for you, which can be disconcerting at some point.  The objects that <c>git</c> stores and tracks are collections of <em>changes</em> to your files.  One such collection might make several small changes to several different files (perhaps you renamed a character in your novel throughout your book), or the change may be to add a new file (a new chapter, say).  As you instruct <c>git</c> to move between branches, you might see your character's name change back and forth, or you might see your new chapter entirely disappear, only to reappear later.  The files in your project are the cumulative result of many changes applied in sequence, not some final state that never regresses to an earlier state.  But don't panic, <c>git</c> has all your changes stored away safely.  <c>git</c> manages changes to your files, and those changes are accumulated in files, whose state may change in ways you are not accustomed to.</p>

        <p>If that sounds scary, realize I am self-taught when it comes to <c>git</c> and have never lost any work.  I have panicked.  I have gained valuable experience puzzling my way out of some jams (see <xref ref="oops" />).  And once I ended up applying the same collection of changes twice, mysteriously getting two of everything in a chapter (see <xref provisional="stash-pop-or-apply" />).</p>
    </introduction>

    <section>
        <title>Commits</title>

        <p>Collections of changes can be called <term>changesets</term>, but we will be more likely to call each one a <term>commit</term>.  That is a noun, not a verb.  If you have some experience with other revision control systems, then you might be familiar with the notion of <q>commiting</q>, or <q>checking in.</q>  Try to avoid confusing the new noun with your old verbs.</p>

        <p>How do you make a commit?  Roughly, you edit your files, so that your directory of files (your <q>working directory</q>) is <q>dirty.</q>  The <term>dirty</term> or <term>clean</term> directory is a good mental image as you start working with <c>git</c>.  Edit your files, and save your files.  Normally, you feel pretty secure at this point.  You have made changes, and by saving the edited files, you feel like you have saved your changes.  But from <c>git</c>'s perspective, your files are dirty and you have not made your changes known to <c>git</c> yet.  Here is the drill, using two commands at the command line in a terminal.</p>

        <list xml:id="making-a-commit">
            <title>Making a Commit</title>
            <ol>
                <li><p>Edit some files and save them, making your working directory dirty.</p></li>
                <li><p><c>git add &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;</c></p></li>
                <li><p><c>git commit -m "Add the incident at the train station"</c></p></li>
            </ol>
        </list>

        <p>You will get no reaction (output) from the <c>git add</c> command, but when you actually make the commit, you should get a response like <pre>
        [master c0f19a2] Add the incident at the train station
        </pre></p>

        <p>OK, that is a basic recipe, but what actually happened?  In the <c>add</c> command you would have listed some, or all, of the files you had edited and saved.  If you only listed some, the commit would only contain some of your changes, and the remaining changes would contribute to keeping your working directory dirty.  The <c>add</c> command moves your changes to a staging area, a sort of purgatory, called the <term>index</term>.  You can incrementally add changes to the index to form a coherent set of changes that will become a commit.  For example, you could have run the <c>add</c> command several times, once for each file, to stage the same collection of changes.</p>

        <p>Realize that <c>git add</c> does two similar things.  If <c>git</c> is unaware of some file, then <c>add</c> will make it one of the files that <c>git</c> <term>tracks</term> and will put the current contents of that file into the index.  And from now on, <c>git</c> will include relevant details about this file.  For example if the file is dirty, then certain reports will show the changes (see next paragraph).  But <q>tracking</q> <em>does not</em> mean <c>git</c> keeps track of changes.  You have control of which changes <c>git</c> manages, and when <c>git</c> becomes aware of them.  Subsequently, <c>git add</c> moves changes from a file into the index, and you can do this repeatedly to update which collection of changes are staged in the index.</p>

        <p>With all this talk of a dirty directory, how can you tell if your directory is even dirty at all?  The command is <c>git diff</c>.  It takes no action and is merely informative.  You can run it anytime you like and it is wise to do it often, especially when getting started.  I often walk away from my writing with a dirty directory (not best practice).  So it is a good habit I have to <em>always</em> run <c>git diff</c> when I first return to a project.  The output of <c>git diff</c> is all of the changes in your working directory that are not staged into the index.  It is organized by file (given in yellow on my computer), with red text being removed and green text being added.  White text is unchanged and provides context for changed text, in order to help <c>git</c> apply changes in the right places.  Solid red squares or bars are extraneous whitespace that serves no purpose other than to potential confuse <c>git</c>.  It is a good idea to become comfortable understanding this information.  When all your changes are in the index, your working directory is now clean, and <c>git diff</c> reports nothing.</p>

        <p><c>git diff</c> drops you into a simple program known as a <term>pager</term>.  The down and up arrows work to scroll through the output, the spacebar advances by a screenful, and the <c>b</c> key takes you back a screenful.  Press <c>h</c> for help on more commands, and use <c>q</c> to quit and exit.</p>

        <p>As you add changes to the index, you can see what your future commit looks like by running <c>git diff --cached</c>, which will report the accumulated changes in the index.</p>

        <p>After all this add'ing and diff'ing, making the commit itself is straightforward.  <c>git commit</c> will do the job<mdash />moving changes from the index into a single collection of changes, a changeset, to be stored, managed and manipulated by <c>git</c>.  Technically, this is an irreversible action, but in practice there are many ways to back up and have a do-over, especially when you are solo, so don't panic.</p>

        <p>The <c>-m</c> switch allows you to make a <term>commit message</term> on the command line, which you should enclose in quotation marks (single or double, allowing use of the other kind in your message, if needed).  Without it, <c>git</c> will dump you in your editor, a step I prefer to avoid.  Either way, you will always want to include a commit message.  They can have multiple lines, but in practice I like to keep them to one concise line, leading with a capitalized action verb, and not more than about sixty characters.  These messages will help you find your way in your <c>git</c> repository, and they will be the first thing others see if they peruse your repository.  I think they are worth some thought toward making them informative and helpful, rather than sloppy and uninformative.  You are an author, no?  Treat your commit messages much like the entries that form a Table of Contents.</p>

        <p>Unlike <c>git add</c>, the <c>git commit</c> command does acknowledge that something happened.  The message shown above has the name of the branch (<c>master</c>) and the commit message.  But what is <c>c0f19a2</c>?  Every commit you ever create gets a hexadecimal identifier that is probabilistically unique across all the <c>git</c> repositories ever made and that will ever be made.  And the first seven characters are usually good enough to uniquely identify commits within your repository.</p>

        <p>Try the new command <c>git log</c>.  It may not show much, but it will list information on every commit on your current branch.  And you will see some huge commit hashes.  There are <m>268\,435\,456</m> different possibilities for seven hexadecimal digits.  A full 40-digit commit hash has about <m>10^{48}</m> possibilities.  This is not a technical aside, we will see soon enough the critical role commit hashes play in a <c>git</c> repository (see <xref ref="commit-hashes" />).  Even though your commit about the train station incident might often be shown shorthand as <c>c0f19a2</c>, it may in reality be<pre>
        c0f19a223404c394d592661532747527038754e
        </pre>which you would see in the log.</p>

        <p>Two more diagnostic commands.  <c>git status</c> will tell you which files are dirty, which files have changes staged in the index and destined for the next commit, and which files are lurking about in your directory, but which you have not ever told <c>git</c> about.  This is a good command to run frequently, especially when you are beginning.  Finally <c>git ls-files</c> will output all the files <c>git</c> has changes for.  This one is interesting, but less usefull day-to-day.</p>

        <p>We will primarly teach by guiding you through exercises.  They almost always have extra information, so read them just for that.  Experiment with a scratch repository where you can try different things without the inevitable mistakes also being worrisome disasters.  And realize you can always start over.</p>

        <exercise xml:id="my-first-repository">
            <title>My First Repository</title>

            <statement>
                <ol>
                    <li>
                        <p>Consult <xref ref="git-start" /> for instructions, setup <c>git</c>, and <c>init</c> an empty repository.</p>
                    </li>
                    <li>
                        <p>Make several commits, creating and adding at least three files into the repository.  Use <c>git diff</c>, <c>git diff --cached</c>, <c>git status</c>, and <c>git log</c> liberally in the process.</p>

                        <p>Put some non-trivial content into each file (though it does not need to be excessive).  We will use this repository for future exercises, so do not get rid of it.  Put a typographical mistake into one of your three files.</p>
                    </li>
                    <li>
                        <p>Do not experiment with branches, we will do that next.</p>
                    </li>
                    <li>
                        <p>Once completed, use <c>git show master</c> to see the changes in your last commit, in the diff format.  Use <c>git show master~1</c> to see the commit just prior to that one.  And <c>git show master~2</c> for the one before that.  Try replacing the references (<c>master~N</c>) by the first seven or eight digits of the commit hash, which you can get from the log, and see that this is the functional equivalent.</p>
                    </li>
                </ol>

                <p>When you are done, the logical arrangement of your commits might look like the following diagram.  We list older commits at the bottom and do not include commit messages.  We use a 4-digit hash, which will uniquely identify each commit.  The name with the arrow points to the <term>tip</term> of the branch with that name.  The commit at the bottom, the first commit ever, is known as the <term>root commit</term>.  As your repository gains more branches, it will look more and more like a tree than a twig.  This diagram should be similar in spirit to what <c>git log</c> reports.</p>

                <figure xml:id="repo-my-first">
                    <caption>Completed First Repository</caption>

                </figure>
            </statement>
        </exercise>
    </section>

    <section>
        <title>Branches</title>

        <p>The term <term>branch</term> gets used many ways in <c>git</c>, as a verb and a noun, likely because it is so fundamental.  We will introduce you to this concept with an exercise, that will also give you some idea of the power of the idea.  So even if you do not work the example right away, read through it, since it contains a lot of explanation.</p>

        <exercise xml:id="hero-heroine-edit">
            <title>Hero and Heroine on Branches</title>

            <statement>
                <p>Make sure your practice repository has at least three files in it, with one typographic mistake.  So go ahead and create a new file and a new commit if you need to.  We will wait.</p>

                <p>We are going to pretend that we are writing a novel and we want to design two possible endings.  In one, the hero dies, and in the other, the heroine dies.</p>

                <p>Make sure your working directory is clean and type <c>git branch heroine</c>.  Not much will appear to have just happened.  So here is a new diagnostic command you will want to use all the time.  Type <c>git show-branch</c>.  This shows all of your possible branches, with an asterisk (<q><c>*</c></q>) indicating the branch your are <q>on</q>.  It is not very informative since your repository is just beginning to take shape and you have only just <em>created</em> a branch.  Be sure to keep this output visible in your terminal for an upcoming comparison.</p>

                <p>Now we are going to move to you new branch.  Ready?  Type <c>git checkout heroine</c>.  Now run <c>git show-branch</c> again and compare to the previous output.  The big change is that the asterisk has moved to indicate the <c>heroine</c> branch.  We say you are now <q>on</q> the <c>heroine</c> branch.  If you have experience with other revision control systems, the word <q>checkout</q> is fraught with other meanings that are not accurate.  Sorry, just get over it.  In <c>git</c> the <c>checkout</c> command will change the files in your working directory to some possibly different state, based on a different sequence of changes in commits.  (Remember, commits are collections of changes.)</p>

                <p>Choose one of your two files without a typo and edit it to include some words about the heroine dying, and also remove some existing words at the same time.  Use <c>git diff</c>, <c>git add</c>, <c>git commit</c> to form a new commit that is the changes you just made, and with a commit message about creating an ending where the heroine dies.  You should have a clean working directory after the commit.</p>

                <p>Now <c>show-branch</c> will show something interesting:</p>
                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git show-branch</input>
                    <output>
                    * [heroine] Create an ending where the heroine dies
                     ! [master] &lt;message about last commit on master&gt;
                    --
                    *  [heroine] Create an ending where the heroine dies
                    *+ [master] &lt;message about last commit on master&gt;
                    </output>
                </console>
                <p>The top half lists all your branches, with color-coding and identifying symbols.  The bottom half tries to describe to you how those branches relate.  We will make it more interesting shortly.</p>

                <p>Close any files you have open in your editor, type <c>git checkout master</c>, and open the files again.  Don't panic.  You have restored your working directory to the state of all the accumulated changes up to the tip of the <c>master</c> branch, so you do not see your most recent change to your novel.  The changes that constitute the brilliant ending about the death of the heroine is saved by <c>git</c> in a place that it is hard for you to find.  Would you like your ending back?  Close your files, type <c>git checkout heroine</c>, and open your files.  <c>git</c> has manipulated your files and applied the changes with the ending, so now your novel should contain the new ending.</p>

                <p>Perhaps you now see why <c>git</c> can feel a bit foreign and why at some point you will have that <q>Oh, <ampersand /><backslash /><hash />*!</q> feeling.  Don't panic.  <c>git</c> manipulates the state of the files in your working directory, so in a way those files are ethereal.  <c>git</c> stores your commits (collections) of changes safely and can rewind and replay them in ways consistent with your writing while on various branches, using your working directory as a sort of sandbox or laboratory.</p>

                <p>Switch back and forth several times between the <c>master</c> and <c>heroine</c> branches with <c>git checkout</c>.  Close and open your files in your editor as you let <c>git</c> manipulate your working directory.  Run <c>git show-branch</c> liberally.  When you are ready, leave a file open when you know a <c>checkout</c> is going to change it.  How does your editor react?  We don't know, so can't help.  But a good editor might say something like <q>File on disk changed, do you want to reload it?</q>  My editor just silently reloads the file, unless I had unsaved edits in it by mistake.  If a <c>git</c> <c>checkout</c> results in a file not even being present, my editor leaves it in a state I find very confusing.  Sometimes this sort of behavior can be configured in a editor.  Experiment until this is not confusing and in the meantime as yu are learning, close and reopen files as you let <c>git</c> manipulate your working directory.</p>

                <p>Ready for another branch?  Make sure you are on <c>master</c> (by running <c>git checkout master</c>).  Then make a new branch, <c>git branch hero</c>, switch to it, and <c>git checkout hero</c>.  Run <c>git show-branch</c> as you go, thinking carefully about how the output is changing.</p>

                <p>Open a file <em>different</em> than the one you edited before, and not the one with the typo.  Remove some words, and author an ending where the hero dies.  Make a commit (we might say <q>commit your changes</q> from now on) using a commit message about the hero dying.  <c>show-branch</c> will show you something like:</p>
                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git show-branch</input>
                    <output>
                    * [hero] Made an ending where the hero is dead
                     ! [heroine] Create an ending where the heroine dies
                      ! [master] &lt;message about last commit on master&gt;
                    ---
                    *   [hero] Made an ending where the hero is dead
                     +  [heroine] Create an ending where the heroine dies
                    *++ [master] &lt;message about last commit on master&gt;
                    </output>
                </console>
                <p>Now this is interesting.  You have three branches, you are <q>on</q> the <c>hero</c> branch, and the <c>heroine</c> and <c>hero</c> branches contain divergent storylines based on a common beginning. (Everything up to <c>master</c> is common and not reported.)  Experiment checking out different branches, run <c>show-branch</c> liberally, and do not foget that you can do things like <c>git show hero</c> even if you are not presently on the <c>hero</c> branch.  Get comfortable with the current state of your repository.  Notice that each of our two new branches could each be a sequence of many commits, but we just need one commit each for the purposes of this exercise.</p>

                <p>As you looked around, did you notice that typographical error you made in the third file when you first start writing?  (If not, play along.)  Checkout the <c>master</c> branch, open the file with the typo and and edit to correct the mistake.  Commit those changes.</p>
                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git show-branch</input>
                    <output>
                    ! [hero] Made an ending where the hero is dead
                     ! [heroine] Create an ending where the heroine dies
                      * [master] Correct a misspelling
                    ---
                      * [master] Correct a misspelling
                    +   [hero] Made an ending where the hero is dead
                     +  [heroine] Create an ending where the heroine dies
                    ++* [master^] &lt;message about last commit on master&gt;
                    </output>
                </console>

                <p>Notice that the new commit has resulted in the tip of the <c>master</c> branch moving to be the commit with the typo fix.  Every commit we have made so far has also moved the <term>branch pointer</term> to a new tip, but this is the first time it was really interesting and significant.  Notice that through all these pointer movements we no longer have a pointer to the commit where all the branches originated.  Notice two that this report still shows the last of our pre-exercise commits, since that is where our three branches diverged from common material.</p>

                <p>The good news is that we have two versions of our story and only fixed the typo once, while the bad news is that the <c>master</c> branch has advanced and left the <c>hero</c> and <c>heroine</c> branches behind.  Do you see that in the output above?  As you checkout the three branches, you will see the effect of the three editing sessions, but they are all disjoint.  Said differently, switching to the <c>hero</c> branch results in <c>git</c> manipulating your working directory by applying a sequence of commits that do not contain the commit with the typo fix.  And similarly for the <c>heroine</c> branch.  But not all is lost.</p>

                <p>Here is where you begin to learn how to leverage <c>git</c>.  We are going to rewind the <c>hero</c> branch back to the commit where the branch began, and then we are going to replay our changes at the new tip of the <c>master</c> branch.  And <c>git</c> knows just how far to rewind.  (This would be slightly more interesting if our <c>hero</c> branch had multiple commits beyond the old branch point.)</p>

                <p>Ready?  Make sure your files are closed, and checkout the <c>hero</c> branch, since this is the branch we are changing.  Run <c>git log</c> in advance because we want to see how the commit hashes behave.  Now run <c>git rebase master</c>.  This tells <c>git</c> to rewind the current branch (<c>hero</c>), checkout <c>master</c>, branch off <c>master</c>, and replay the commits that were just rewound (in the opposite order), leaving the <c>hero</c> branch pointer at the tip of the branch.  Remember, <c>git</c> manipulates the files in your working directory by applying (replaying) commits in sequence.</p>

                <p>You might be aware that in replaying the commits, <c>git</c> might get confused by intermediate changes that had not been present when the commits were based on the original branch point.  These situations are known as <term>conflicts</term>.  <c>git</c> can be pretty smart about these, but sometimes they require intervention by the author.  If you have followed our instructions and used three files, then this will not happen in this exercise.</p>

                <p>Open your files and you should see the hero dying, and you should also see the typo fixed.  When I need to run this command, I say to myself <q><c>rebase</c> the current branch onto <c>master</c></q> to make sure I get it right and do the right thing.  Examine the result with <c>git show-branch</c>.</p>

                <p>Repeat this procedure to bring the <c>heroine</c> branch up-to-date with the changes on <c>master</c>.  This is an exercise, so we will not hold your hand on this one.  When you are done, you should see:</p>
                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git show-branch</input>
                    <output>
                    ! [hero] Made an ending where the hero is dead
                     * [heroine] Create an ending where the heroine dies
                      ! [master] Correct a misspelling
                    ---
                    +   [hero] Made an ending where the hero is dead
                     *  [heroine] Create an ending where the heroine dies
                    +*+ [master] Correct a misspelling
                    </output>
                </console>
                <p>Notice that <em>all</em> of the commits for the beginning of the story, prior to our typo fix are not shown in this output because they are now common to all the branches.</p>

                <p>Before you experiment too much, checkout the <c>hero</c> branch, and as beforehand, run <c>git log</c>.  You should see that the first commit (hero dies) has a <em>totally different</em> commit hash, the second commit is the typo fix (which was not evident beforehand), and the present third commit is the previous second commit, with the <em>identical</em> commit hash.  We will discuss this outside of the exercise.  Now, explore your repository thorougly with the various commands and diagnostics you have learned.</p>

                <p>That is it, we are done.  Notice that you are maintaining two versions of your novel, can easily switch between working on one or the other, and you can edit common material just once in a way that is reflected in each version.  If you made a mess of this (which might be a good thing), just start over with a new repository having a single commit with your three files all added in at once and make a do-over.  Or maybe  repeat the exercise with extra commits on each branch for a fuller experience and to solidify your new skills.</p>
            </statement>
        </exercise>

        <p>The previous exercise begs the question: what to do once we decide which ending we want?  The next exercise has the answer.</p>

        <exercise xml:id="heroine-dies">
            <title>Heroine Meets Her End</title>

            <statement>
                <p>Having thoroughly explored the possibilites, we have decided to kill off the heroine as the ending of our novel.  Briefly, we are going to take all the changes from the <c>heroine</c> branch and move them onto the <c>master</c> branch.  Then we will deal with the <c>hero</c> branch.</p>

                <!-- 842f83c is old master pointer, c7fe82d is new master pointer -->
                <p>First, checkout the <c>master</c> branch since that is the branch we will be changing.  Then it is as simple as <c>git merge heroine</c>.  Through this <term>merge</term> you have taken the changes from the <c>heroine</c> branch and brought them into the <c>master</c> branch.  You should have output something like:</p>
                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git merge heroine</input>
                    <output>
                    Updating 842f83c..c7fe82d
                    Fast-forward
                     some-file.txt | 4 ++--
                     1 file changed, 2 insertions(+), 2 deletions(-)
                    </output>
                </console>
                <p>The file listed should be the one you edited with the story of the death of the heroine.  For more diagnostics:</p>
                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git show-branch</input>
                    <output>
                    ! [hero] Made an ending where the hero is dead
                     ! [heroine] Create an ending where the heroine dies
                      * [master] Create an ending where the heroine dies
                    ---
                    +   [hero] Made an ending where the hero is dead
                     +* [heroine] Create an ending where the heroine dies
                    ++* [hero^] Correct a misspelling
                    </output>
                </console>
                <p>Now the <c>heroine</c> and <c>master</c> branches are identical, and the <c>master</c> pointer has advanced one commit, so that the <c>hero</c> branch still splits off prematurely from <c>master</c>, but the <c>heroine</c> branch does not.</p>

                <p>Running <c>git log</c> you will see that the second commit (the typo fix) was reported by the merge as a short commit hash in the output (<c>XXXX</c>) and the first commit (the heroine ending) is also reported by the merge via a short commit hash (<c>XXXX</c>).  This is the movement of the <c>master</c> branch pointer, indiocated by <c>..</c> between the hashes.</p>

                <p>This is actually a very special type of merge, known as a <term>fast-forward</term> merge, as reported in the output.  Since the <c>heroine</c> branch splits off from the tip of the <c>master</c> branch, it is trivial to rewind all the <c>heroine</c> commits back to <c>master</c> and then replay them onto <c>master</c>.  Think about that for a minute.  Not only is it trivial, it borders on silly.</p>

                <p>Here is what really happens in a fast-forward merge.  No commits are rewound and replayed.  <c>git</c> simply moves the <c>master</c> branch pointer from its original location, so that it points to the same commit as the one that <c>heroine</c> points to.  This has two implications.  First, none of the commits on the <c>heroine</c> branch change in any way.  Second, once the merge is completed <c>master</c> and <c>heroine</c> are redundant, as they point to the same commit, as you can see in the top half of the output from <c>show-branch</c> where the commit message is duplicated.</p>

                <p>The previous paragraph is an important realization, but you might be wise to forget about it.  In the long run, it is better to think of this merge as bringing (merging) the changes on <c>heroine</c> into <c>master</c>.  That is the more general situation, and I recall the simpler version of describing a fast-forward merge as confusing general ideas later.</p>

                <p>Now we have a bit of a mess on our hands.  The <c>heroine</c> branch pointer is redundant, but really it is obsolete.  Our trial death of the herione is no longer experimental, we have decided that is the ending we want and now it is part of <c>master</c>.  Let us kill the <c>heroine</c> branch pointer too.</p>

                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git branch -d heroine</input>
                    <output>
                    Deleted branch heroine (was c7fe82d)
                    </output>
                </console>

                <p>Note in the output the short-version commit hash for the commit that is the current tip of <c>master</c>, that is what <c>heroine</c> also pointed to.  Most of your work will initially reside on branches, so deleting a branch pointer sounds like a dangerous thing to do, and it is.  But <c>git</c> has your back.  Try the following:</p>

                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git branch -d master</input>
                    <output>error: Cannot delete the branch 'master' which you are currently on.</output>
                </console>

                <p>That is good.  We would not want to delete the branch we were on, we would be totally lost.  So let us try cleaning up another part of our mess.  We still have the <c>hero</c> branch, with the ending we did not choose.  Let us delete that:</p>

                <console>
                    <prompt>rob@lava:~/books/ppw$ </prompt>
                    <input>git branch -d hero</input>
                    <output>
                    error: The branch 'hero' is not fully merged.
                    If you are sure you want to delete it, run 'git branch -D hero'.
                    </output>
                </console>

                <p>When we deleted the branch pointer to <c>heroine</c>, <c>git</c> knew it was redundant and happily deleted it at once.  But the branch pointer <c>hero</c> lets us reference commits we cannot locate any other way, specifically the commit where we let the hero die.  So <c>git</c> makes us be a bit more certain and we need the upper-case variant of the switch to get rid of it.  Be careful, because if you lose track of commits, they can be hard to resurrect and eventually <c>git</c> will <term>garbage collect</term> them when it does some automatic spring cleaning of yur repository.  For us, there is no real harm in leaving the <c>hero</c> branch in place.  It is doing no damage where it is, we do not ever need to check it out, though eventually we will grow tired of seeing it in all our diagnostic reports.</p>
            </statement>
        </exercise>

        <p>Realize that the decision above to merge <c>heroine</c> into <c>master</c> should not be taken lightly, as it is quite difficult to reverse it, and not really in the spirit of how you use <c>git</c>.  Branches like <c>hero</c> and <c>heroine</c> are sometimes called <term>topic branches</term>.  Or in a nod to software development they may be called <term>feature branches</term>, since they might be used to create and test a new feature for a larger piece of software.  I like to refer to a branch like <c>master</c> as the <term>mainline</term>.  An essential aspect of working with <c>git</c> is to always work on a branch, and realize that there is little cost to making a branch, merging it, and then deleting the (temporary) branch pointer.  I have made branches that only had a lifetime of five minutes.  That is a principle.</p>

        <principle xml:id="principle-branch-often">
            <title>Always Work on a Branch</title>

            <statement>
                <p>Always make a topic branch off your mainline when starting new work, and only merge once satisfied.</p>
            </statement>
        </principle>
    </section>

    <section>
        <title>Commit Hashes</title>

        <p>In computer science, a <term>hash function</term> is a many-to-one function that takes lengthy input, massages it, and produces vastly shorter output of a fixed length, called the <term>hash</term>.  While the output looks random, the function has no randomness, and the actual function is well-known to everyone.  Identical inputs will always produce the same output.  But if two inputs differ even slightly, they will have wildly different outputs<mdash />this is a design criteria for most hash functions.  Similarly, we might require that if we know the hash (output), it is very hard to manufacture input to the hash function to produce that output.  For the hash function used in <c>git</c> it is highly unlikely that two different inputs (commits) will produce the same output (hash).  So the commit hash is similar to how we use fingerprints or retinal scans to identify humans.  If you want to learn more, <c>git</c> uses the <term>SHA-1</term> hash function, whose tamperproof properties were designed for use in cryptographic applications.  It is no longer considered secure for that purpose, but works fine for use in <c>git</c>.</p>

        <p>The input <c>git</c> uses to form the hash include things like your name, the date, the commit message, the changes in the commit, and <em>most importantly</em>, the commit hash of the previous commit in the sequence on the branch.  This is similar to the <term>blockchain</term> technology used in BitCoin, and lately a darling of fintech (financial technology).  A sequence of blocks of information and their hashes, each formed with input including the previous hash, makes it practically impossible to tamper with any one piece of information without radically disturbing every subsequent hash.</p>

        <p>Return to the fast-forward merge above to see that there was absolutely no change in the information for each commit and there was no disruption in the sequence (chain) of commits.  As explained, the only thing that really happened was that the <c>master</c> block pointer was changed to point to a new commit, the tip of the <c>heroine</c> branch.</p>

        <p>Contrast that to when we rebased the <c>hero</c> branch onto the <c>master</c> branch that contained the typo fix.  <c>git</c> rewound the commits on <c>hero</c> up to the old branch point, but then replayed them onto a commit (the tip of <c>master</c>) with a different commit hash.  All of the replayed commits from the <c>hero</c> branch (we just had one) will have their commit hashes recomputed and will be radically different since the hash of the tip of <c>master</c> is an input to the first one.  The previous hash(es) are meaningless (and lost to time).  Notice that <c>git</c> updates the branch pointer <c>hero</c> to use a new hash from the tip of the replayed branch.</p>

        <p>This is a principle that will be important once we get social and work with others.</p>

        <principle xml:id="principle-rebase-merge">
            <title>A Rebase Changes Hashes, a Merge Does Not</title>

            <statement>
                <p>A rebase will always change some commit hashes, while a merge will never change any commit hashes.</p>
            </statement>
        </principle>
    </section>

    <conclusion>
        <p>You now know, and have experience with, four of the six important concepts of working with <c>git</c>: committing, branching, rebasing and fast-forward merging.  Only (general) merging and pull requests remains.  But first, let us get social and begin collaborating with others, to realize some of the most powerful aspects of <c>git</c>.</p>
    </conclusion>
</chapter>
